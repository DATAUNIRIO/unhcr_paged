---
title: "How to quickly produce statistical reports? "
author: "The UNHCR \"_R-Cookbook_\""
date: "Version: `r Sys.Date()`"
output:
  pagedown::html_paged:
    toc: true
    # change to true for a self-contained document, but it'll be a litte slower for Pandoc to render
    self_contained: true
    toc-title: Contents
    paged-footnotes: true
    css:
    - css/unhcr_page_custom.css
    - css/unhcr_page.css
    - css/unhcr_page_fonts.css   
---


```{r setup, include=FALSE, echo=TRUE, warning=FALSE}
pacman::p_load('dplyr', 'tidyr', 'gapminder',
               'ggplot2',  'ggalt',
               'forcats', 'R.utils', 'png', 
               'grid', 'ggpubr', 'scales',
               'bbplot', 'knitr', 'pander')
options(scipen = 999)
```


This R cookbook is designed to make the process of creating publication-ready graphics and reports with UNHCR style a more __reproducible process__. The cookbook aims as well at making it easier for people new to R to create graphics. It implements a specific theme (using `ggplot2` R library) and report template (using `pagedown`  R library). 

The cookbook below should hopefully help anyone who wants to make advanced graphics and gain efficiency in the generation of statistical reports. All the code below is ready to be copy pasted. This report template itself, as it comes with UNHCR branding style, can also easily be r-used. 


This document has been largely inspired by the [BBC cookbook](https://bbc.github.io/rcookbook/).


# Graphics with "_style_"

## Importance of reproducibility

Reproducibility is key in data analysis: 

 * it can save a lot of time when very similar analysis have to be done in different operation or point in time, 
 
 * It allows to quickly to scan the analysis workflow and point potential errors,
 
 * It allows for peer review and/or can help peers to learn from what is presented.
 
 

## Load all the libraries you need

We'll get to how you can put together the various elements of these graphics, but **let's get the admin out of the way first...**

A few of the steps in this cookbook - and to create charts in R in general - require certain packages to be installed and loaded. So that you do not have to install and load them one by one, you can use the `p_load` function in the `pacman` package to load them all at once with the following code. 

```{r , eval=FALSE}
# This line of code installs the pacman page if you do not have it installed 
# - if you do, it simply loads the package
if(!require(pacman))install.packages("pacman")
pacman::p_load('dplyr', 'tidyr', 'gapminder', 'ggplot2',  'ggalt',
               'forcats', 'R.utils', 'png', 'grid', 'ggpubr', 'scales', 'bbplot')
```


The style is based first on the function: `unhcr_style()`. The `unhcr_style()` function essentially modifies certain arguments in the `theme` function of `ggplot2`.

``` {r }

unhcr_style <- function() {
  font <- "Lato"
  ggplot2::theme(
    
#This sets the font, size, type and colour of text for the chart's title
  plot.title = ggplot2::element_text(family=font, size=20, face = "bold", color = "#222222"),

#This sets the font, size, type and colour of text for the chart's subtitle,  as well as setting a margin between the title and the subtitle
  plot.subtitle = ggplot2::element_text(family=font, size=16, margin=ggplot2::margin(9,0,9,0)),
  plot.caption = ggplot2::element_blank(),

#This sets the position and alignment of the legend, removes a title and backround for it and sets the requirements for any text within the legend. The legend may often need some more manual tweaking when it comes to its exact position based on the plot coordinates.
  legend.position = "top",
  legend.text.align = 0,
  legend.background = ggplot2::element_blank(),
  legend.title = ggplot2::element_blank(),
  legend.key = ggplot2::element_blank(),
  legend.text = ggplot2::element_text(family=font, size=18, color = "#222222"),

#This sets the text font, size and colour for the axis test, as well as setting the margins and removes lines and ticks. In some cases, axis lines and axis ticks are things we would want to have in the chart
  axis.title = ggplot2::element_blank(),
  axis.text = ggplot2::element_text(family=font, size=18, color = "#222222"),
  axis.text.x = ggplot2::element_text(margin=ggplot2::margin(5, b = 10)),
  axis.ticks = ggplot2::element_blank(),
  axis.line = ggplot2::element_blank(),

#This removes all minor gridlines and adds major y gridlines. In many cases you will want to change this to remove y gridlines and add x gridlines. 
  panel.grid.minor = ggplot2::element_blank(),
  panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
  panel.grid.major.x = ggplot2::element_blank(),

#This sets the panel background as blank, removing the standard grey ggplot background colour from the plot
  panel.background = ggplot2::element_blank(),

#This sets the panel background for facet-wrapped plots to white, removing the standard grey ggplot background colour and sets the title size of the facet-wrap title to font size 22
  strip.background = ggplot2::element_rect(fill = "white"),
  strip.text = ggplot2::element_text(size  = 16,  hjust = 0)
  )
}

``` 


`unhcr_style()`: has no arguments and is added to the ggplot 'chain' after you have created a plot. What it does is generally makes text size, font and colour, axis lines, axis text, margins and many other standard chart components into UNHCR style, which has been formulated based on recommendations and feedback from the design team.

Note that colours for lines in the case of a line chart or bars for a bar chart, do not come out of the box from the `unhcr_style()` function, but need to be explicitly set in your other standard `ggplot` chart functions.

You can modify these settings for your chart, or add additional theme arguments, by calling the `theme` function with the arguments you want - but please note that for it to work you must call it _after_ you have called the `unhcr_style` function. Otherwise `unhcr_style()` will override it. 

The following for instance will add some gridlines, by adding extra theme arguments to what is included in the `unhcr_style()` function. There are many similar examples throughout the cookbook.

```{r eval=FALSE}
theme(panel.grid.major.x = element_line(color = "#cbcbcb"), 
        panel.grid.major.y = element_blank())
```

A specific statement is used to aligne the chart, it's title, subtitle and source

`ggpubr::ggarrange(left_align(line, c("subtitle", "title")), ncol = 1, nrow = 1)`

It use a specific function `left_align()`:


``` {r }
#Left align text
left_align <- function(plot_name, pieces){
  grob <- ggplot2::ggplotGrob(plot_name)
  n <- length(pieces)
  grob$layout$l[grob$layout$name %in% pieces] <- 2
  return(grob)
}

```


## Report template with pagedown

[Pagedown](https://github.com/rstudio/pagedown) is a package that allows to transform an R Markdown  file into an htlm files, directly paginated (with CSS for Print) to be saved as PDF. With Pagedown, you only need a modern web browser (e.g., Google Chrome) to generate PDF.

This package requires a recent version of Pandoc (>= 2.2.3). If you use RStudio, you are recommended to install the Preview version (>= 1.2.1070), which has bundled Pandoc 2.x, otherwise you need to install Pandoc separately.

A dedicated template - used in this document - allows to implement quickly and directly UNHCR branding.


## Chart to convey "_stories_"

Effective chart are first those that support a message. From the same dataset a multiplicity of chart can be produced. The best chart is the one that present in the most powerful way the message that you want to pass-on. 

Simples rules can help to achived this:

 * __Outline the message__: Always use the main conclusion you want to draw within the title of the chart, use the subtitle to present the data that you have used in the chart. annotation in the chart can also help explaining why the chart is an evidence of the message you present.
 
 * __Do keep the chart as simple as possible__. Edward Tufte, a statistician, said “_Graphical elegance is often found in simplicity of design and complexity of data._” 
 
 * __Focus on legibility__: For bar graph presenting categories, do use a horizontal bar graph and arrange data from greatest to least in descending order. 
 
 * __Reshape first your data__:Don’t use more than six colors or six different categories within the same chart: human brain cannot process more than this. 


By using this cookbook, you can benefit from a simple and lean style and focus on your data and message, rather than wasting time on chart beautification and report design. 


# Generate different kind of plots

## Line chart

```{r message = FALSE}
#Prepare data
line_df <- gapminder %>%
  filter(country == "China") 
#Make plot
line <- ggplot(line_df, aes(x = year, y = lifeExp)) +
  
  geom_line(colour = "#0072bc", size = 1) +
  
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  labs(title = "Living longer",
       subtitle = "Life expectancy in China 1952-2007")
```

```{r echo=FALSE}
#plot(line)
ggpubr::ggarrange(left_align(line, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Multiple line chart

```{r}
#Prepare data
multiple_line_df <- gapminder %>%
  filter(country == "China" | country == "United States") 
#Make plot
multiple_line <- ggplot(multiple_line_df, aes(x = year, y = lifeExp, colour = country)) +
  geom_line(size = 1) +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  scale_colour_manual(values = c("#FAAB18", "#0072bc")) +
  unhcr_style() +
  labs(title = "Living longer",
       subtitle = "Life expectancy in China and the US")
```


```{r echo=FALSE}
#plot(multiple_line)
ggpubr::ggarrange(left_align(multiple_line, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Bar chart

```{r}
#Prepare data
bar_df <- gapminder %>%
  filter(year == 2007 & continent == "Africa") %>%
  arrange(desc(lifeExp)) %>%
  head(5)
#Make plot
bars <- ggplot(bar_df, aes(x = country, y = lifeExp)) +
  geom_bar(stat = "identity", 
           position = "identity", 
           fill = "#0072bc") +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  labs(title = "Reunion is highest",
       subtitle = "Highest African life expectancy, 2007")
```

```{r echo=FALSE}
#plot(bars)
ggpubr::ggarrange(left_align(bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Stacked bar chart

```{r}
#prepare data
stacked_df <- gapminder %>% 
  filter(year == 2007) %>%
  mutate(lifeExpGrouped = cut(lifeExp, 
                    breaks = c(0, 50, 65, 80, 90),
                    labels = c("Under 50", "50-65", "65-80", "80+"))) %>%
  group_by(continent, lifeExpGrouped) %>%
  summarise(continentPop = sum(as.numeric(pop)))
#set order of stacks by changing factor levels
stacked_df$lifeExpGrouped = factor(stacked_df$lifeExpGrouped, levels = rev(levels(stacked_df$lifeExpGrouped)))
#create plot
stacked_bars <- ggplot(data = stacked_df, 
                       aes(x = continent,
                           y = continentPop,
                           fill = lifeExpGrouped)) +
  geom_bar(stat = "identity", 
           position = "fill") +
  unhcr_style() +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_viridis_d(direction = -1) +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  labs(title = "How life expectancy varies",
       subtitle = "% of population by life expectancy band, 2007") +
  theme(legend.position = "top", 
        legend.justification = "left") +
  guides(fill = guide_legend(reverse = TRUE))
```

```{r echo=FALSE}
#plot(stacked_bars)
ggpubr::ggarrange(left_align(stacked_bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

This example shows proportions, but you might want to make a stacked bar chart showing number values instead - this is easy to change!

The value passed to the `position` argument will determine if your stacked chart shows proportions or actual values. 

`position = "fill"` will draw your stacks as proportions, and `position = "identity"` will draw number values. 

## Grouped bar chart

Making a grouped bar chart is very similar to making a bar chart. 

You just need to change `position = "identity"` to `position = "dodge"`, and set the `fill` aesthetically instead:

```{r}
#Prepare data
grouped_bar_df <- gapminder %>%
  filter(year == 1967 | year == 2007) %>%
  select(country, year, lifeExp) %>%
  spread(year, lifeExp) %>%
  mutate(gap = `2007` - `1967`) %>%
  arrange(desc(gap)) %>%
  head(5) %>%
  gather(key = year, 
         value = lifeExp,
         -country,
         -gap) 
  
#Make plot
grouped_bars <- ggplot(grouped_bar_df, 
                       aes(x = country, 
                           y = lifeExp, 
                           fill = as.factor(year))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  scale_fill_manual(values = c("#0072bc", "#FAAB18")) +
  labs(title = "We're living longer",
       subtitle = "Biggest life expectancy rise, 1967-2007")
```

```{r echo=FALSE}
#plot(grouped_bars)
ggpubr::ggarrange(left_align(grouped_bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Dumbbell chart

Another way of showing difference is a dumbbell chart:

```{r}
library("ggalt")
library("tidyr")
#Prepare data
dumbbell_df <- gapminder %>%
  filter(year == 1967 | year == 2007) %>%
  select(country, year, lifeExp) %>%
  spread(year, lifeExp) %>%
  mutate(gap = `2007` - `1967`) %>%
  arrange(desc(gap)) %>%
  head(10)
#Make plot
ggplot(dumbbell_df, aes(x = `1967`, xend = `2007`, y = reorder(country, gap), group = country)) + 
  geom_dumbbell(colour = "#dddddd",
                size = 3,
                colour_x = "#FAAB18",
                colour_xend = "#0072bc") +
  unhcr_style() + 
  labs(title = "We're living longer",
       subtitle = "Biggest life expectancy rise, 1967-2007")
```

## Histogram

```{r message = FALSE, warning = FALSE}
hist_df <- gapminder %>%
  filter(year == 2007)
ggplot(hist_df, aes(lifeExp)) +
  geom_histogram(binwidth = 5, colour = "white", fill = "#0072bc") +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  scale_x_continuous(limits = c(35, 95),
                     breaks = seq(40, 90, by = 10),
                     labels = c("40", "50", "60", "70", "80", "90 years")) +
  labs(title = "How life expectancy varies",
       subtitle = "Distribution of life expectancy in 2007")
```

-----------------------------

# Make changes to the legend

## Remove the legend

Remove the legend to become one - it's better to label data directly with text annotations.

Use `guides(colour=FALSE)` to remove the legend for a specific aesthetic (replace `colour` with the relevant aesthetic). 

```{r eval=FALSE}
multiple_line + guides(colour=FALSE)
```

You can also remove all legends in one go using `theme(legend.position = "none")`:

```{r}
multiple_line + theme(legend.position = "none")
```

## Change the position of the legend

The legend's default position is at the top of your plot. Move it to the left, right or bottom outside the plot with:

```{r}
multiple_line + theme(legend.position = "right")
```

To be really precise about where we want our legend to go, instead of specifying "right" or "top" to change the general position of where the legend appears in our chart, we can give it specific coordinates. 

For example `legend.position=c(0.98,0.1)` will move the legend to the bottom right. For reference, c(0,0) is bottom left, c(1,0) is bottom right, c(0,1) is top left and so on). Finding the exact position may involve some trial and error. 

To check the exact position where the legend appears in your finalised plot you will have to check the file that is saved out after you run your `finalise_plot()` function, as the position will be relevant to the dimensions of the plot.

```{r eval=FALSE}
  multiple_line + theme(legend.position = c(0.115,1.05),
                      legend.direction = "horizontal") +  
  labs(title = "Living longer",
       subtitle = "Life expectancy in China and the US\n")
```

To get the legend flush against the left side of your chart, it may be easier to set a negative left margin for the legend using `legend.margin`. The syntax is `margin(top, right, bottom, left)`. 

You'll have to experiment to find the correct number to set the margin to for your chart - save it out with `finalise_plot()` and see how it looks.

```{r eval=FALSE}
  + theme(legend.margin = margin(0, 0, 0, -200))
```

## Remove the legend title

Remove the legend title by tweaking your `theme()`. Don't forget that for any changes to the theme to work, they must be added after you've called `unhcr_style()`!

```{r eval = FALSE}
+ theme(legend.title = element_blank())
```

## Reverse the order of your legend

Sometimes you need to change the order of your legend for it to match the order of your bars. For this, you need `guides`:

```{r eval = FALSE}
+ guides(fill = guide_legend(reverse = TRUE))
```

## Rearrange the layout of your legend

If you've got many values in your legend, you may need to rearrange the layout for aesthetic reasons. 

You can specify the number of rows you want your legend to have as an argument to `guides`. The below code snippet, for instance, will create a legend with 4 rows:

```{r eval = FALSE}
+ guides(fill = guide_legend(nrow = 4, byrow = T))
```

You may need to change `fill` in the code above to whatever aesthetic your legend is describing, e.g. `size`, `colour`, etc.

## Change the appearance of your legend symbols

You can override the default appearance of the legend symbols, without changing the way they appear in the plot, by adding the argument `override.aes` to `guides`. 

The below will make the size of the legend symbols larger, for instance:

```{r eval = FALSE}
+ guides(fill = guide_legend(override.aes = list(size = 4))))
```

## Add space between your legend labels

The default ggplot legend has almost no space between individual legend items. Not ideal.

You can add space by changing the scale labels manually. 

For instance, if you have set the colour of your geoms to be dependent on your data, you will get a legend for the colour, and you can tweak the exact labels to get some extra space in by using the below snippet:

```{r eval = F}
+ scale_colour_manual(labels = function(x) paste0(" ", x, "  "))
```

If your legend is showing something different, you will need to change the code accordingly. For instance, for fill, you will need `scale_fill_manual()` instead. 

# Make changes to the axes

## Flip the coordinates of a plot

Add `coord_flip()` to make your vertical bars horizontal:

```{r}
bars <- bars + coord_flip()
```

```{r echo=FALSE}
#plot(bars)
ggpubr::ggarrange(left_align(bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Add/remove gridlines

The default theme only has gridlines for the y axis. Add x gridlines with `panel.grid.major.x = element_line`. 

(Similarly, remove the gridlines on the y axis with `panel.grid.major.y = element_blank()`)

```{r}
bars <- bars + coord_flip() +
  theme(panel.grid.major.x = element_line(color = "#cbcbcb"), 
        panel.grid.major.y = element_blank())
```

```{r echo=FALSE}
#plot(bars)
ggpubr::ggarrange(left_align(bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Change the axis text manually

You can change the axis text labels freely with `scale_y_continuous` or `scale_x_continuous`:

```{r}
bars <- bars + scale_y_continuous(limits=c(0,85),
                   breaks = seq(0, 80, by = 20),
                   labels = c("0","20", "40", "60", "80 years"))
#plot(bars)
ggpubr::ggarrange(left_align(bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

This will also specify the limits of your plot as well as where you want axis ticks.

## Add thousand separators to your axis labels

You can specify that you want your axis text to have thousand separators with an argument to `scale_y_continuous`. 

There are two ways of doing this, one in base R which is a bit fiddly:

```{r eval = FALSE}
+ scale_y_continuous(labels = function(x) format(x, big.mark = ",",
                                                 scientific = FALSE))
```

The second way relies on the `scales` package, but is much more concise:

```{r eval = FALSE}
+ scale_y_continuous(labels = scales::comma)
```

## Add percent symbol to your axis labels

This is also easy to add with an argument to `scale_y_continuous`:

```{r eval = FALSE}
+ scale_y_continuous(labels = function(x) paste0(x, "%"))
```

## Change the plot limits

The long way of setting the limits of your plot explicitly is with `scale_y_continuous` as above. But if you don't need to specify the breaks or labels the shorthand way of doing it is with `xlim` or `ylim`:

```{r}
bars + ylim(c(0,500))
```

## Add axis titles

Our default theme has no axis titles, but you may wish to add them in manually. This is done by modifying `theme()` - note that you must do this after the call to `unhcr_style()` or your changes will be overridden:

```{r eval = FALSE}
+ theme(axis.title = element_text(size = 18))
```

## Modify axis titles

If you add in axis titles, they will by default be the column names in your dataset. You can change this to anything you want in your call to `labs()`. 

For instance, if you wish your x axis title to be "I'm an axis" and your y axis label to be blank, this would be the format:

```{r eval = FALSE}
+ labs(x = "I'm an axis", 
       y = "")
```

## Add axis ticks

You can add axis tick marks by adding `axis.ticks.x` or `axis.ticks.y` to your `theme`:

```{r}
multiple_line + theme(
  axis.ticks.x = element_line(colour = "#333333"), 
  axis.ticks.length =  unit(0.26, "cm"))
```

# Add annotations

## Insert labels

The easiest way to add a text annotation to your plot is using `geom_label`: 

```{r}
multiple_line + geom_label(aes(x = 1980, y = 45, label = "I'm an annotation!"), 
                           hjust = 0, 
                           vjust = 0.5, 
                           colour = "#555555", 
                           fill = "white", 
                           label.size = NA, 
                           family="Helvetica", 
                           size = 6)
```

The exact positioning of the annotation will depend on the `x` and `y` arguments (which is a bit fiddly!) and the text alignment, using `hjust` and `vjust` - but more on that below.

Add line breaks where necessary in your label with `\n`, and set the line height with `lineheight`. 

```{r}
multiple_line <- multiple_line + 
  geom_label(aes(x = 1980, y = 45, label = "I'm quite a long\nannotation over\nthree rows"), 
             hjust = 0, 
             vjust = 0.5, 
             lineheight = 0.8,
             colour = "#555555", 
             fill = "white", 
             label.size = NA, 
             family="Helvetica", 
             size = 6) 
```

Let's get our direct labels in there!

```{r}
multiple_line <- multiple_line + 
  theme(legend.position = "none") + 
  xlim(c(1950, 2011)) +
  geom_label(aes(x = 2007, y = 79, label = "US"), 
             hjust = 0, 
             vjust = 0.5, 
             colour = "#0072bc", 
             fill = "white", 
             label.size = NA, 
             family="Helvetica", 
             size = 6) +
  geom_label(aes(x = 2007, y = 72, label = "China"), 
             hjust = 0, 
             vjust = 0.5, 
             colour = "#FAAB18", 
             fill = "white", 
             label.size = NA, 
             family="Helvetica", 
             size = 6)
```

```{r echo=FALSE}
#plot(multiple_line)
ggpubr::ggarrange(left_align(multiple_line, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Left-align/right-align text

The arguments `hjust` and `vjust` dictate horizontal and vertical text alignment. They can have a value between 0 and 1, where 0 is left-justified and 1 is right-justified (or bottom- and top-justified for vertical alignment).

##  Add labels based on your data

The above method for adding annotations to your chart lets you specify the x and y coordinates exactly. This is very useful if we want to add a text annotation in a specific place, but would be very tedious to repeat. 

Fortunately, if you want to add labels to all your data points, you can simply set the position based on your data instead. 

Let's say we want to add data labels to our bar chart:

```{r}
labelled.bars <- bars +
  geom_label(aes(x = country, y = lifeExp, label = round(lifeExp, 0)),
             hjust = 1, 
             vjust = 0.5, 
             colour = "white", 
             fill = NA, 
             label.size = NA, 
             family="Helvetica", 
             size = 6)
labelled.bars
```

The above code automatically adds one text label for each continent, without us having to add `geom_label` five separate times. 

(If you're confused about why we're setting the `x` as the continents and `y` as life expectancy, when the chart appears to be drawing them the other way around, it's because we've flipped the coordinates of the plot using `coord_flip()`, which you can [read more about here](https://github.com/bbc/vjdata.rcookbook#flip-the-coordinates-of-a-plot).)

##  Add left-aligned labels to bar charts

If you'd rather add left-aligned labels for your bars, just set the `x` argument based on your data, but specify the `y` argument directly instead, with a numeric value. 

The exact value of `y` will depend on the range of your data. 

```{r}
labelled.bars.v2 <- bars +
  geom_label(aes(x = country, 
                 y = 4, 
                 label = round(lifeExp, 0)),
             hjust = 0, 
             vjust = 0.5, 
             colour = "white", 
             fill = NA, 
             label.size = NA, 
             family="Helvetica", 
             size = 6)
labelled.bars.v2
```

## Add a line

Add a line with `geom_segment`:

```{r}
multiple_line + geom_segment(aes(x = 1979, y = 45, xend = 1965, yend = 43), 
                             colour = "#555555", 
                             size=0.5)
```

The `size` argument specifies the thickness of the line. 

## Add a curved line

For a curved line, use `geom_curve` instead of `geom_segment`:

```{r}
multiple_line + geom_curve(aes(x = 1979, y = 45, xend = 1965, yend = 43), 
                           colour = "#555555", 
                           curvature = -0.2,
                           size=0.5)
```

The `curvature` argument sets the amount of curve: 0 is a straight line, negative values give a left-hand curve and positive values give a right-hand curve.

## Add an arrow

Turning a line into an arrow is fairly straightforward: just add the `arrow` argument to your `geom_segment` or `geom_curve`:

```{r}
multiple_line + geom_curve(aes(x = 1979, y = 45, xend = 1965, yend = 43), 
                             colour = "#555555", 
                             size=0.5, 
                             curvature = -0.2,
                             arrow = arrow(length = unit(0.03, "npc")))
```

The first argument to `unit` sets the size of the arrowhead. 

## Add a line across the whole plot

The easiest way to add a line across the whole plot is with `geom_vline()`, for a vertical line, or `geom_hline()`, for a horizontal one. 

Optional additional arguments allow you to specify the size, colour and type of line (the default option is a solid one).

```{r}
multiple_line + geom_hline(yintercept = 10, size = 1, colour = "red", linetype = "dashed")
```

The line obviously doesn't add much in this example, but this is useful if you want to highlight something, e.g. a threshold level, or an average value. 

It's also especially useful because our design style - as you may already have noticed from the charts on this page - is to add a vertical or horizontal baseline to our charts. This is the code to use:

```{r eval = FALSE}
+ geom_hline(yintercept = 0, size = 1, colour = "#333333")
```

# Work with small multiples

Small multiple charts are easy to create with ggplot: it's called faceting.

## Facets

If you have data that you want to visualise split up by some variable, you need to use `facet_wrap` or `facet_grid`. 

Add the variable you want to divide by to this line of code: `facet_wrap( ~ variable)`.

An additional argument to facet wrap, `ncol`, allows you to specify the number of columns:

```{r}
#Prepare data
facet <- gapminder %>%
  filter(continent != "Americas") %>%
  group_by(continent, year) %>%
  summarise(pop = sum(as.numeric(pop)))
#Make plot
facet_plot <- ggplot() +
  geom_area(data = facet, aes(x = year, y = pop, fill = continent)) +
  scale_fill_manual(values = c("#FAAB18", "#0072bc","#990000", "#588300")) + 
  facet_wrap( ~ continent, ncol = 5) + 
  scale_y_continuous(breaks = c(0, 2000000000, 4000000000),
                     labels = c(0, "2bn", "4bn")) +
  unhcr_style() +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) +
  labs(title = "Asia's rapid growth",
       subtitle = "Population growth by continent, 1952-2007")
```

```{r echo=FALSE}
plot(facet_plot)

```

## Free scales

You may have noticed in the chart above that Oceania, with its relatively small population, has disappeared completely. 

By default, faceting uses fixed axis scales across the small multiples. It's always best to use the same y axis scale across small multiples, to avoid misleading, but sometimes you may need to set these independently for each multiple, which we can do by adding the argument `scales = "free"`. 

If you just want to free the scales for one axis set the argument to `free_x` or `free_y`. 

```{r}
#Make plot
facet_plot_free <- ggplot() +
  geom_area(data = facet, aes(x = year, y = pop, fill = continent)) +
  facet_wrap(~ continent, scales = "free") + 
  unhcr_style() +
  scale_fill_manual(values = c("#FAAB18", "#0072bc","#990000", "#588300")) +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  theme(legend.position = "none",
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) +
  labs(title = "It's all relative",
       subtitle = "Relative population growth by continent,1952-2007")
```

```{r echo=FALSE}
#plot(facet_plot_free)

ggpubr::ggarrange(left_align(facet_plot_free, c("subtitle", "title")), ncol = 1, nrow = 1)

```

# Do something else entirely

## Increase or decrease margins

You can change the margin around almost any element of your plot - the title, subtitles, legend - or the plot itself. 

You shouldn't ordinarily need to change the default margins from the theme but if you do, the syntax is `theme(ELEMENT=element_text(margin=margin(0, 5, 10, 0)))`. 

The numbers specify the top, right, bottom, and left margin respectively - but you can also specify directly which margin you want to change. For example, let's try giving the subtitle an extra-large bottom margin: 

```{r}
bars + theme(plot.subtitle=element_text(margin=margin(b=75)))
```

Hm... maybe not. 

## Exporting your plot and x-axis margins

You do need to think about your x-axis margin sizes when you are producing a plot that is beyond the default height in `bbplot`, which is 450px. This could be the case for example if you are creating a bar chart with lots of bars and want to make sure there is some breathing space between each bar and labels. If you do leave the margins as they are for plots with a greater height, then you could get a larger gap between the axis and your labels.

Here is a guide that we work to when it comes to the margins and the height of your bar chart (with coord_flip applied to it):

```{r echo = F, prepping_table, results = 'asis'} 
size <- c("550px", "650px", "750px", "850px")
t <- c(5, 7, 10, 14) 
b <- c(rep(10, 4))
table <- data.frame(size, t, b)
pandoc.table(table, style = 'rmarkdown') 
```

So what you'd need to do is add this code to your chart if for example you wanted the height of your plot to be 650px instead of 450px. 

```{r}
bar_chart_tall <- bars + theme(axis.text.x = element_text(margin=margin(t = 7, b = 10)))
#bar_chart_tall

ggpubr::ggarrange(left_align(bar_chart_tall, c("subtitle", "title")), ncol = 1, nrow = 1)
```

Although it is much less likely, but if you do want to do the equivalent for a line chart and export it at a larger than default height, you need to do the same but change your values for t to negative values based on the table above. 

## Reorder bars by size

By default, R will display your data in alphabetical order, but arranging it by size instead is simple: just wrap `reorder()` around the `x` or `y` variable you want to rearrange, and specify which variable you want to reorder it by. 

E.g. `x = reorder(country, pop)`. Ascending order is the default, but you can change it to descending by wrapping `desc()` around the variable you're ordering by:

```{r}
bars <- ggplot(bar_df, aes(x = reorder(country, lifeExp), y = lifeExp)) +
  geom_bar(stat = "identity", position = "identity", fill = "#0072bc") +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  coord_flip() +
  labs(title = "Reunion is highest",
       subtitle = "Highest African life expectancy, 2007") +
  theme(panel.grid.major.x = element_line(color = "#cbcbcb"), 
        panel.grid.major.y = element_blank())
```

```{r echo=FALSE}
#plot(bars)

ggpubr::ggarrange(left_align(bars, c("subtitle", "title")), ncol = 1, nrow = 1)
```

## Reorder bars manually

Sometimes you need to order your data in a way that isn't alphabetical or reordered by size. 

To order these correctly you need to set your data's factor levels before making the plot.

Specify the order you want the categories to be plotted in the `levels` argument:

```{r eval=FALSE}
dataset$column <- factor(dataset$column, levels = c("18-24","25-64","65+"))
```

You can also use this to reorder the stacks of a stacked bar chart. 

## Colour bars conditionally

You can set aesthetic values like fill, alpha, size conditionally with `ifelse()`. 

The syntax is `fill=ifelse(logical_condition, fill_if_true, fill_if_false)`. 

```{r}
highlighted <- ggplot(bar_df, 
       aes(x = reorder(country, lifeExp), y = lifeExp)) +
  geom_bar(stat = "identity", position = "identity", 
           fill = ifelse(bar_df$country == "Mauritius", "#0072bc", "#CCCCCC")) +
  geom_hline(yintercept = 0, size = 1, colour = "#333333") +
  unhcr_style() +
  coord_flip() +
  labs(title = "Reunion is highest",
       subtitle = "Highest African life expectancy, 2007") +
  theme(panel.grid.major.x = element_line(color = "#cbcbcb"), 
        panel.grid.major.y = element_blank()) 


ggpubr::ggarrange(left_align(highlighted , c("subtitle", "title")), ncol = 1, nrow = 1)
```
